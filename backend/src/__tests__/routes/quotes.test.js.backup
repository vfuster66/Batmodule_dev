// Mock des dépendances AVANT les imports
jest.mock('../../middleware/auth');
jest.mock('../../config/database');
jest.mock('../../services/pdfService');
jest.mock('../../services/calculationService');
jest.mock('../../services/auditService');
jest.mock('crypto');
jest.mock('nodemailer');

const request = require('supertest');
const express = require('express');
const quotesRouter = require('../../routes/quotes');
const { authenticateToken } = require('../../middleware/auth');
const { query, transaction } = require('../../config/database');
const pdfService = require('../../services/pdfService');
const calculationService = require('../../services/calculationService');
const { logAudit } = require('../../services/auditService');
const crypto = require('crypto');
const nodemailer = require('nodemailer');

const app = express();
app.use(express.json());
app.use('/quotes', quotesRouter);

describe('Quotes Routes', () => {
    let mockQuery, mockTransaction;

    beforeEach(() => {
        // Reset all mocks
        jest.clearAllMocks();

        // Recreate mock functions
        mockQuery = jest.fn();
        mockTransaction = jest.fn();

        // Reconfigure mocks - IMPORTANT: utiliser mockImplementation pour chaque test
        query.mockImplementation(mockQuery);
        transaction.mockImplementation(mockTransaction);

        authenticateToken.mockImplementation((req, res, next) => {
            req.user = { userId: 'test-user-id' };
            next();
        });

        // Mock calculationService par défaut
        calculationService.validateItems.mockReturnValue({ isValid: true });
        calculationService.calculateTotals.mockReturnValue({
            subtotalHt: 1000,
            totalVat: 200,
            totalTtc: 1200
        });

        // Mock crypto par défaut
        crypto.randomBytes.mockReturnValue(Buffer.from('test-token'));

        // Mock nodemailer par défaut
        nodemailer.createTransport.mockReturnValue({
            sendMail: jest.fn().mockResolvedValue({ messageId: 'msg123' })
        });

        // Mock auditService par défaut
        logAudit.mockResolvedValue();

        // Mock pdfService par défaut
        pdfService.generateQuotePDF.mockResolvedValue(Buffer.from('PDF content'));
    });

    describe('GET /quotes', () => {
        it('should work with simple mocks', async () => {
            // Test complètement indépendant
            const simpleMockQuery = jest.fn();
            query.mockImplementation(simpleMockQuery);

            simpleMockQuery
                .mockResolvedValueOnce({ rows: [] })
                .mockResolvedValueOnce({ rows: [{ total: '0' }] });

            const response = await request(app)
                .get('/quotes');

            expect(response.status).toBe(200);
            expect(response.body).toHaveProperty('quotes');
            expect(response.body).toHaveProperty('pagination');
        });

        it('should return all quotes for authenticated user', async () => {
            // Test très simple - juste vérifier que ça ne fait pas d'erreur 500
            mockQuery.mockResolvedValueOnce({ rows: [] });
            mockQuery.mockResolvedValueOnce({ rows: [{ total: '0' }] });

            const response = await request(app)
                .get('/quotes');

            // Vérifier que la réponse est correcte
            expect(response.status).toBe(200);
            expect(response.body).toHaveProperty('quotes');
            expect(response.body).toHaveProperty('pagination');
            expect(response.body.quotes).toHaveLength(0);
            expect(response.body.pagination).toMatchObject({
                page: 1,
                limit: 20,
                total: 0,
                pages: 0
            });
        });

        it('should filter quotes by status', async () => {
            const mockCount = { rows: [{ total: '0' }] };
            mockQuery.mockResolvedValueOnce({ rows: [] });
            mockQuery.mockResolvedValueOnce(mockCount);

            await request(app)
                .get('/quotes?status=draft')
                .expect(200);

            expect(mockQuery).toHaveBeenCalledWith(
                expect.stringContaining('AND q.status = $2'),
                expect.arrayContaining(['test-user-id', 'draft'])
            );
        });

        it('should filter quotes by client', async () => {
            const mockCount = { rows: [{ total: '0' }] };
            mockQuery.mockResolvedValueOnce({ rows: [] });
            mockQuery.mockResolvedValueOnce(mockCount);

            await request(app)
                .get('/quotes?clientId=client-1')
                .expect(200);

            expect(mockQuery).toHaveBeenCalledWith(
                expect.stringContaining('AND q.client_id = $2'),
                expect.arrayContaining(['test-user-id', 'client-1'])
            );
        });

        it('should handle pagination', async () => {
            const mockCount = { rows: [{ total: '0' }] };
            mockQuery.mockResolvedValueOnce({ rows: [] });
            mockQuery.mockResolvedValueOnce(mockCount);

            await request(app)
                .get('/quotes?page=2&limit=10')
                .expect(200);

            expect(mockQuery).toHaveBeenCalledWith(
                expect.stringContaining('LIMIT $2 OFFSET $3'),
                expect.arrayContaining(['test-user-id', '10', 10])
            );
        });

        it('should handle database errors', async () => {
            mockQuery.mockRejectedValueOnce(new Error('Database error'));

            await request(app)
                .get('/quotes')
                .expect(500);
        });
    });

    describe('GET /quotes/:id', () => {
        it('should return a specific quote with items and sections', async () => {
            const mockQuote = {
                id: 'quote-1',
                client_id: 'client-1',
                quote_number: 'DEV-2023-0001',
                title: 'Devis Test',
                description: 'Description test',
                status: 'draft',
                subtotal_ht: 1000.00,
                total_vat: 200.00,
                total_ttc: 1200.00,
                valid_until: '2023-12-31',
                notes: 'Notes test',
                created_at: '2023-01-01T00:00:00Z',
                updated_at: '2023-01-01T00:00:00Z',
                site_same_as_billing: false,
                site_address_line1: '456 Site St',
                site_address_line2: null,
                site_postal_code: '75002',
                site_city: 'Lyon',
                site_country: 'France',
                first_name: 'John',
                last_name: 'Doe',
                company_name: 'Test Company',
                email: 'john@test.com',
                phone: '0123456789',
                address_line1: '123 Test St',
                address_line2: null,
                postal_code: '75001',
                city: 'Paris',
                country: 'France'
            };

            const mockItems = [
                {
                    id: 'item-1',
                    section_id: 'section-1',
                    service_id: 'service-1',
                    description: 'Service test',
                    quantity: 1,
                    unit_price_ht: 1000.00,
                    unit_price_ttc: 1200.00,
                    vat_rate: 20.00,
                    unit: 'm²',
                    discount_percent: 0,
                    markup_percent: 0,
                    total_ht: 1000.00,
                    total_ttc: 1200.00,
                    sort_order: 0
                }
            ];

            const mockSections = [
                {
                    id: 'section-1',
                    title: 'Section Test',
                    description: 'Description de la section',
                    sort_order: 0,
                    created_at: '2023-01-01T00:00:00Z',
                    updated_at: '2023-01-01T00:00:00Z'
                }
            ];

            mockQuery
                .mockResolvedValueOnce({ rows: [mockQuote] })
                .mockResolvedValueOnce({ rows: mockItems })
                .mockResolvedValueOnce({ rows: mockSections });

            const response = await request(app)
                .get('/quotes/quote-1')
                .expect(200);

            expect(response.body.quote).toMatchObject({
                id: 'quote-1',
                quoteNumber: 'DEV-2023-0001',
                title: 'Devis Test',
                status: 'draft',
                subtotalHt: 1000,
                totalVat: 200,
                totalTtc: 1200
            });
            expect(response.body.quote.client).toMatchObject({
                id: 'client-1',
                firstName: 'John',
                lastName: 'Doe',
                companyName: 'Test Company',
                email: 'john@test.com'
            });
            expect(response.body.quote.siteAddress).toMatchObject({
                sameAsBilling: false,
                addressLine1: '456 Site St',
                postalCode: '75002',
                city: 'Lyon',
                country: 'France'
            });
            expect(response.body.quote.items).toHaveLength(1);
            expect(response.body.quote.sections).toHaveLength(1);
        });

        it('should return 404 if quote not found', async () => {
            mockQuery.mockResolvedValueOnce({ rows: [] });

            const response = await request(app)
                .get('/quotes/non-existent')
                .expect(404);

            expect(response.body.error).toBe('Devis non trouvé');
        });
    });

    describe('POST /quotes', () => {
        it('should create a new quote successfully', async () => {
            const newQuote = {
                clientId: '123e4567-e89b-12d3-a456-426614174000',
                title: 'Nouveau Devis',
                description: 'Description du devis',
                validUntil: '2023-12-31',
                notes: 'Notes du devis',
                depositPercent: 30,
                siteSameAsBilling: false,
                siteAddressLine1: '456 Site St',
                sitePostalCode: '75002',
                siteCity: 'Lyon',
                siteCountry: 'France',
                items: [
                    {
                        description: 'Service test',
                        quantity: 1,
                        unitPriceHt: 1000,
                        vatRate: 20
                    }
                ]
            };

            const mockClient = { rows: [{ id: 'client-1' }] };
            const mockSettings = { rows: [{ quote_prefix: 'DEV', quote_counter: 0 }] };
            const mockYearCount = { rows: [{ cnt: '0' }] };
            const mockQuote = {
                id: 'quote-2',
                quote_number: 'DEV-2023-0001',
                title: 'Nouveau Devis',
                description: 'Description du devis',
                status: 'draft',
                subtotal_ht: 1000.00,
                total_vat: 200.00,
                total_ttc: 1200.00,
                valid_until: '2023-12-31',
                notes: 'Notes du devis',
                deposit_amount: 360.00,
                deposit_paid: false,
                site_same_as_billing: false,
                site_address_line1: '456 Site St',
                site_address_line2: null,
                site_postal_code: '75002',
                site_city: 'Lyon',
                site_country: 'France',
                created_at: '2023-01-01T00:00:00Z',
                updated_at: '2023-01-01T00:00:00Z'
            };
            const mockItem = {
                id: 'item-2',
                service_id: null,
                description: 'Service test',
                quantity: 1,
                unit_price_ht: 1000.00,
                unit_price_ttc: 1200.00,
                vat_rate: 20.00,
                unit: null,
                discount_percent: 0,
                markup_percent: 0,
                total_ht: 1000.00,
                total_ttc: 1200.00,
                sort_order: 0
            };

            mockQuery
                .mockResolvedValueOnce(mockClient)
                .mockResolvedValueOnce(mockSettings)
                .mockResolvedValueOnce(mockYearCount);

            calculationService.validateItems.mockReturnValue({ isValid: true });
            calculationService.calculateTotals.mockReturnValue({
                subtotalHt: 1000,
                totalVat: 200,
                totalTtc: 1200,
                items: [{
                    serviceId: null,
                    description: 'Service test',
                    quantity: 1,
                    unitPriceHt: 1000,
                    unitPriceTtc: 1200,
                    vatRate: 20,
                    totalHt: 1000,
                    totalTtc: 1200,
                    sortOrder: 0,
                    sectionId: null
                }]
            });

            mockTransaction.mockImplementation(async (callback) => {
                const mockClient = {
                    query: jest.fn()
                        .mockResolvedValueOnce({ rows: mockSettings })
                        .mockResolvedValueOnce({ rows: mockYearCount })
                        .mockResolvedValueOnce({ rows: [mockQuote] })
                        .mockResolvedValueOnce({ rows: [mockItem] })
                };
                return await callback(mockClient);
            });

            const response = await request(app)
                .post('/quotes')
                .send(newQuote)
                .expect(201);

            expect(response.body.message).toBe('Devis créé avec succès');
            expect(response.body.quote.quoteNumber).toBe('DEV-2023-0001');
            expect(response.body.quote.title).toBe('Nouveau Devis');
            expect(response.body.quote.items).toHaveLength(1);
        });

        it('should create quote with sections', async () => {
            const newQuote = {
                clientId: '123e4567-e89b-12d3-a456-426614174000',
                title: 'Devis avec Sections',
                sections: [
                    {
                        title: 'Section 1',
                        description: 'Description section 1',
                        sortOrder: 0,
                        items: [
                            {
                                description: 'Service 1',
                                quantity: 1,
                                unitPriceHt: 500,
                                vatRate: 20
                            }
                        ]
                    },
                    {
                        title: 'Section 2',
                        description: 'Description section 2',
                        sortOrder: 1,
                        items: [
                            {
                                description: 'Service 2',
                                quantity: 1,
                                unitPriceHt: 500,
                                vatRate: 20
                            }
                        ]
                    }
                ]
            };

            const mockClient = { rows: [{ id: 'client-1' }] };
            const mockSettings = { rows: [{ quote_prefix: 'DEV', quote_counter: 0 }] };
            const mockYearCount = { rows: [{ cnt: '0' }] };
            const mockQuote = {
                id: 'quote-3',
                quote_number: 'DEV-2023-0001',
                title: 'Devis avec Sections',
                status: 'draft',
                subtotal_ht: 1000.00,
                total_vat: 200.00,
                total_ttc: 1200.00,
                created_at: '2023-01-01T00:00:00Z',
                updated_at: '2023-01-01T00:00:00Z'
            };

            mockQuery
                .mockResolvedValueOnce(mockClient)
                .mockResolvedValueOnce(mockSettings)
                .mockResolvedValueOnce(mockYearCount);

            calculationService.validateItems.mockReturnValue({ isValid: true });
            calculationService.calculateTotals.mockReturnValue({
                subtotalHt: 1000,
                totalVat: 200,
                totalTtc: 1200,
                items: [
                    {
                        serviceId: null,
                        description: 'Service 1',
                        quantity: 1,
                        unitPriceHt: 500,
                        unitPriceTtc: 600,
                        vatRate: 20,
                        totalHt: 500,
                        totalTtc: 600,
                        sortOrder: 0,
                        sectionId: 'section-1'
                    },
                    {
                        serviceId: null,
                        description: 'Service 2',
                        quantity: 1,
                        unitPriceHt: 500,
                        unitPriceTtc: 600,
                        vatRate: 20,
                        totalHt: 500,
                        totalTtc: 600,
                        sortOrder: 0,
                        sectionId: 'section-2'
                    }
                ]
            });

            mockTransaction.mockImplementation(async (callback) => {
                const mockClient = {
                    query: jest.fn()
                        .mockResolvedValueOnce({ rows: mockSettings })
                        .mockResolvedValueOnce({ rows: mockYearCount })
                        .mockResolvedValueOnce({ rows: [mockQuote] })
                        .mockResolvedValueOnce({ rows: [{ id: 'section-1', title: 'Section 1', description: 'Description section 1', sort_order: 0 }] })
                        .mockResolvedValueOnce({ rows: [{ id: 'item-1', service_id: null, description: 'Service 1', quantity: 1, unit_price_ht: 500, unit_price_ttc: 600, vat_rate: 20, unit: null, discount_percent: 0, markup_percent: 0, total_ht: 500, total_ttc: 600, sort_order: 0 }] })
                        .mockResolvedValueOnce({ rows: [{ id: 'section-2', title: 'Section 2', description: 'Description section 2', sort_order: 1 }] })
                        .mockResolvedValueOnce({ rows: [{ id: 'item-2', service_id: null, description: 'Service 2', quantity: 1, unit_price_ht: 500, unit_price_ttc: 600, vat_rate: 20, unit: null, discount_percent: 0, markup_percent: 0, total_ht: 500, total_ttc: 600, sort_order: 0 }] })
                };
                return await callback(mockClient);
            });

            const response = await request(app)
                .post('/quotes')
                .send(newQuote)
                .expect(201);

            expect(response.body.message).toBe('Devis créé avec succès');
            expect(response.body.quote.quoteNumber).toBe('DEV-2023-0001');
            expect(response.body.quote.title).toBe('Devis avec Sections');
        });

        it('should return 400 for invalid data', async () => {
            const invalidQuote = {
                clientId: 'invalid-uuid',
                title: '', // Invalid: too short
                items: [] // Invalid: empty items
            };

            const response = await request(app)
                .post('/quotes')
                .send(invalidQuote)
                .expect(400);

            expect(response.body.error).toBe('Données invalides');
            expect(response.body.details).toBeDefined();
        });

        it('should return 404 if client not found', async () => {
            const newQuote = {
                clientId: '00000000-0000-0000-0000-000000000000',
                title: 'Nouveau Devis',
                items: [
                    {
                        description: 'Service test',
                        quantity: 1,
                        unitPriceHt: 1000,
                        vatRate: 20
                    }
                ]
            };

            mockQuery.mockResolvedValueOnce({ rows: [] });

            const response = await request(app)
                .post('/quotes')
                .send(newQuote)
                .expect(404);

            expect(response.body.error).toBe('Client non trouvé');
        });

        it('should validate items', async () => {
            const newQuote = {
                clientId: '123e4567-e89b-12d3-a456-426614174000',
                title: 'Nouveau Devis',
                items: [
                    {
                        description: 'Service test',
                        quantity: -1, // Invalid: negative quantity
                        unitPriceHt: 1000,
                        vatRate: 20
                    }
                ]
            };

            const mockClient = { rows: [{ id: 'client-1' }] };
            mockQuery.mockResolvedValueOnce(mockClient);

            calculationService.validateItems.mockReturnValue({
                isValid: false,
                errors: ['Quantité invalide']
            });

            const response = await request(app)
                .post('/quotes')
                .send(newQuote)
                .expect(400);

            expect(response.body.error).toBe('Données des items invalides');
            expect(response.body.details).toEqual(['Quantité invalide']);
        });
    });

    describe('PUT /quotes/:id/status', () => {
        it('should update quote status successfully', async () => {
            const statusData = { status: 'sent' };
            const mockResult = {
                rows: [{
                    id: 'quote-1',
                    status: 'sent',
                    updated_at: '2023-01-15T00:00:00Z'
                }]
            };

            mockQuery.mockResolvedValueOnce(mockResult);

            const response = await request(app)
                .put('/quotes/quote-1/status')
                .send(statusData)
                .expect(200);

            expect(response.body.message).toBe('Statut du devis mis à jour avec succès');
            expect(response.body.status).toBe('sent');
        });

        it('should return 400 for invalid status', async () => {
            const statusData = { status: 'invalid-status' };

            const response = await request(app)
                .put('/quotes/quote-1/status')
                .send(statusData)
                .expect(400);

            expect(response.body.error).toBe('Statut invalide');
            expect(response.body.message).toBe('Le statut doit être: draft, sent, accepted ou rejected');
        });

        it('should return 404 if quote not found', async () => {
            const statusData = { status: 'sent' };
            mockQuery.mockResolvedValueOnce({ rows: [] });

            const response = await request(app)
                .put('/quotes/non-existent/status')
                .send(statusData)
                .expect(404);

            expect(response.body.error).toBe('Devis non trouvé');
        });
    });

    describe('PUT /quotes/:id', () => {
        it('should update quote successfully', async () => {
            const updateData = {
                title: 'Devis Mis à Jour',
                description: 'Description mise à jour',
                validUntil: '2023-12-31',
                notes: 'Notes mises à jour',
                siteSameAsBilling: true,
                sections: [
                    {
                        title: 'Section Mise à Jour',
                        description: 'Description section mise à jour',
                        items: [
                            {
                                description: 'Service mis à jour',
                                unit: 'm²',
                                quantity: 2,
                                unitPriceHt: 500,
                                vatRate: 20
                            }
                        ]
                    }
                ]
            };

            const mockCurrentQuote = { rows: [{ status: 'draft' }] };
            const mockUpdatedQuote = {
                rows: [{
                    id: 'quote-1',
                    title: 'Devis Mis à Jour',
                    description: 'Description mise à jour',
                    status: 'draft',
                    valid_until: '2023-12-31',
                    notes: 'Notes mises à jour',
                    subtotal_ht: 1000.00,
                    total_vat: 200.00,
                    total_ttc: 1200.00,
                    updated_at: '2023-01-15T00:00:00Z'
                }]
            };

            mockQuery
                .mockResolvedValueOnce(mockCurrentQuote)
                .mockResolvedValueOnce(mockUpdatedQuote)
                .mockResolvedValueOnce({ rows: [] })
                .mockResolvedValueOnce({ rows: [] })
                .mockResolvedValueOnce({ rows: [{ id: 'section-1' }] })
                .mockResolvedValueOnce({ rows: [] });

            calculationService.validateItems.mockReturnValue({ isValid: true });
            calculationService.calculateTotals.mockReturnValue({
                subtotalHt: 1000,
                totalVat: 200,
                totalTtc: 1200,
                items: [{
                    serviceId: null,
                    description: 'Service mis à jour',
                    quantity: 2,
                    unitPriceHt: 500,
                    unitPriceTtc: 600,
                    vatRate: 20,
                    totalHt: 1000,
                    totalTtc: 1200,
                    sortOrder: 0,
                    sectionId: 'section-1'
                }]
            });

            calculationService.calculateItemTotals.mockReturnValue({
                unitPriceTtc: 600,
                totalHt: 1000,
                totalTtc: 1200
            });

            const response = await request(app)
                .put('/quotes/quote-1')
                .send(updateData)
                .expect(200);

            expect(response.body.message).toBe('Devis mis à jour avec succès');
            expect(response.body.quote.title).toBe('Devis Mis à Jour');
            expect(response.body.quote.description).toBe('Description mise à jour');
        });

        it('should return 404 if quote not found', async () => {
            const updateData = {
                title: 'Devis Mis à Jour'
            };

            mockQuery.mockResolvedValueOnce({ rows: [] });

            const response = await request(app)
                .put('/quotes/non-existent')
                .send(updateData)
                .expect(404);

            expect(response.body.error).toBe('Devis non trouvé');
        });

        it('should return 400 for non-draft quote', async () => {
            const updateData = {
                title: 'Devis Mis à Jour'
            };

            const mockCurrentQuote = { rows: [{ status: 'sent' }] };
            mockQuery.mockResolvedValueOnce(mockCurrentQuote);

            const response = await request(app)
                .put('/quotes/quote-1')
                .send(updateData)
                .expect(400);

            expect(response.body.error).toBe('Devis non modifiable (statut non draft)');
        });

        it('should return 400 for invalid update data', async () => {
            const invalidUpdate = {
                title: '',
                sections: [
                    {
                        title: 'Section',
                        items: [
                            {
                                description: 'Service',
                                quantity: -1,
                                unitPriceHt: 500,
                                vatRate: 20
                            }
                        ]
                    }
                ]
            };

            const mockCurrentQuote = { rows: [{ status: 'draft' }] };
            mockQuery.mockResolvedValueOnce(mockCurrentQuote);

            const response = await request(app)
                .put('/quotes/quote-1')
                .send(invalidUpdate)
                .expect(400);

            expect(response.body.error).toBe('Données invalides');
            expect(response.body.details).toBeDefined();
        });
    });

    describe('DELETE /quotes/:id', () => {
        it('should delete quote successfully', async () => {
            const mockResult = { rows: [{ id: 'quote-1' }] };
            mockQuery.mockResolvedValueOnce(mockResult);

            const response = await request(app)
                .delete('/quotes/quote-1')
                .expect(200);

            expect(response.body.message).toBe('Devis supprimé avec succès');
            expect(mockQuery).toHaveBeenCalledWith(
                'DELETE FROM quotes WHERE id = $1 AND user_id = $2 RETURNING id',
                ['quote-1', 'test-user-id']
            );
        });

        it('should return 404 if quote not found', async () => {
            mockQuery.mockResolvedValueOnce({ rows: [] });

            const response = await request(app)
                .delete('/quotes/non-existent')
                .expect(404);

            expect(response.body.error).toBe('Devis non trouvé');
        });
    });

    describe('GET /quotes/:id/pdf', () => {
        it('should generate quote PDF successfully', async () => {
            const mockQuote = {
                id: 'quote-1',
                client_id: 'client-1',
                quote_number: 'DEV-2023-0001',
                title: 'Devis Test',
                description: 'Description test',
                status: 'draft',
                subtotal_ht: 1000.00,
                total_vat: 200.00,
                total_ttc: 1200.00,
                valid_until: '2023-12-31',
                notes: 'Notes test',
                created_at: '2023-01-01T00:00:00Z',
                updated_at: '2023-01-01T00:00:00Z',
                site_same_as_billing: false,
                site_address_line1: '456 Site St',
                site_address_line2: null,
                site_postal_code: '75002',
                site_city: 'Lyon',
                site_country: 'France',
                first_name: 'John',
                last_name: 'Doe',
                company_name: 'Test Company',
                email: 'john@test.com',
                phone: '0123456789',
                address_line1: '123 Test St',
                address_line2: null,
                postal_code: '75001',
                city: 'Paris',
                country: 'France'
            };

            const mockSections = [
                {
                    id: 'section-1',
                    title: 'Section Test',
                    description: 'Description de la section',
                    sort_order: 0
                }
            ];

            const mockItems = [
                {
                    id: 'item-1',
                    section_id: 'section-1',
                    service_id: 'service-1',
                    description: 'Service test',
                    quantity: 1,
                    unit_price_ht: 1000.00,
                    unit_price_ttc: 1200.00,
                    vat_rate: 20.00,
                    unit: 'm²',
                    discount_percent: 0,
                    markup_percent: 0,
                    total_ht: 1000.00,
                    total_ttc: 1200.00,
                    sort_order: 0
                }
            ];

            const mockCompany = {
                rows: [{
                    company_name: 'Test Company',
                    address_line1: '123 Company St',
                    postal_code: '75001',
                    city: 'Paris',
                    country: 'France',
                    phone: '0123456789',
                    email: 'contact@test.com',
                    siret: '12345678901234',
                    vat_number: 'FR12345678901'
                }]
            };

            const mockPdfBuffer = Buffer.from('PDF content');

            mockQuery
                .mockResolvedValueOnce({ rows: [mockQuote] })
                .mockResolvedValueOnce({ rows: mockSections })
                .mockResolvedValueOnce({ rows: mockItems })
                .mockResolvedValueOnce(mockCompany);

            pdfService.generateQuotePDF.mockResolvedValueOnce(mockPdfBuffer);

            const response = await request(app)
                .get('/quotes/quote-1/pdf')
                .expect(200);

            expect(response.headers['content-type']).toBe('application/pdf');
            expect(response.headers['content-disposition']).toBe('attachment; filename="devis-DEV-2023-0001.pdf"');
            expect(response.body).toEqual(mockPdfBuffer);
        });

        it('should return 404 if quote not found', async () => {
            mockQuery.mockResolvedValueOnce({ rows: [] });

            const response = await request(app)
                .get('/quotes/non-existent/pdf')
                .expect(404);

            expect(response.body.error).toBe('Devis non trouvé');
        });
    });

    describe('POST /quotes/:id/send', () => {
        it('should send quote by email successfully', async () => {
            const emailData = {
                to: 'client@test.com',
                cc: 'manager@test.com',
                subject: 'Votre devis',
                message: 'Message personnalisé'
            };

            const mockQuote = {
                id: 'quote-1',
                user_id: 'test-user-id',
                client_id: 'client-1',
                quote_number: 'DEV-2023-0001',
                title: 'Devis Test',
                description: 'Description test',
                status: 'draft',
                subtotal_ht: 1000.00,
                total_vat: 200.00,
                total_ttc: 1200.00,
                valid_until: '2023-12-31',
                notes: 'Notes test',
                created_at: '2023-01-01T00:00:00Z',
                updated_at: '2023-01-01T00:00:00Z',
                site_same_as_billing: false,
                site_address_line1: '456 Site St',
                site_address_line2: null,
                site_postal_code: '75002',
                site_city: 'Lyon',
                site_country: 'France',
                first_name: 'John',
                last_name: 'Doe',
                company_name: 'Test Company',
                email: 'john@test.com',
                phone: '0123456789',
                address_line1: '123 Test St',
                address_line2: null,
                postal_code: '75001',
                city: 'Paris',
                country: 'France'
            };

            const mockItems = [
                {
                    id: 'item-1',
                    section_id: 'section-1',
                    service_id: 'service-1',
                    description: 'Service test',
                    quantity: 1,
                    unit_price_ht: 1000.00,
                    unit_price_ttc: 1200.00,
                    vat_rate: 20.00,
                    unit: 'm²',
                    discount_percent: 0,
                    markup_percent: 0,
                    total_ht: 1000.00,
                    total_ttc: 1200.00,
                    sort_order: 0
                }
            ];

            const mockSections = [
                {
                    id: 'section-1',
                    title: 'Section Test',
                    description: 'Description de la section',
                    sort_order: 0
                }
            ];

            const mockCompany = {
                rows: [{
                    company_name: 'Test Company',
                    address_line1: '123 Company St',
                    postal_code: '75001',
                    city: 'Paris',
                    country: 'France',
                    phone: '0123456789',
                    email: 'contact@test.com',
                    siret: '12345678901234',
                    vat_number: 'FR12345678901'
                }]
            };

            const mockPdfBuffer = Buffer.from('PDF content');
            const mockToken = 'abc123def456';

            mockQuery
                .mockResolvedValueOnce({ rows: [mockQuote] })
                .mockResolvedValueOnce({ rows: mockItems })
                .mockResolvedValueOnce({ rows: mockSections })
                .mockResolvedValueOnce(mockCompany)
                .mockResolvedValueOnce({ rows: [] })
                .mockResolvedValueOnce({ rows: [] })
                .mockResolvedValueOnce({ rows: [] })
                .mockResolvedValueOnce({ rows: [] });

            crypto.randomBytes.mockReturnValueOnce(Buffer.from(mockToken));
            pdfService.generateQuotePDF.mockResolvedValueOnce(mockPdfBuffer);

            const mockTransport = {
                sendMail: jest.fn().mockResolvedValueOnce({ messageId: 'msg123' })
            };
            nodemailer.createTransport.mockReturnValueOnce(mockTransport);

            const response = await request(app)
                .post('/quotes/quote-1/send')
                .send(emailData)
                .expect(200);

            expect(response.body.message).toBe('Devis envoyé');
            expect(response.body.publicUrl).toContain('quotes/quote-1/public');
            expect(response.body.email.messageId).toBe('msg123');
        });

        it('should return 400 for invalid email address', async () => {
            const emailData = {
                to: 'invalid-email',
                subject: 'Votre devis'
            };

            const response = await request(app)
                .post('/quotes/quote-1/send')
                .send(emailData)
                .expect(400);

            expect(response.body.error).toBe('Adresse destinataire invalide');
        });

        it('should return 404 if quote not found', async () => {
            const emailData = {
                to: 'client@test.com',
                subject: 'Votre devis'
            };

            mockQuery.mockResolvedValueOnce({ rows: [] });

            const response = await request(app)
                .post('/quotes/non-existent/send')
                .send(emailData)
                .expect(404);

            expect(response.body.error).toBe('Devis non trouvé');
        });
    });

    describe('Authentication', () => {
        it('should require authentication for all protected routes', async () => {
            authenticateToken.mockImplementationOnce((req, res, next) => {
                res.status(401).json({ error: 'Unauthorized' });
            });

            await request(app)
                .get('/quotes')
                .expect(401);
        });
    });
});
